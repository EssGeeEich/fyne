// Code generated by go run gen.go; DO NOT EDIT.

package async

import (
	"sync"
	"sync/atomic"

	"fyne.io/fyne/v2/internal/driver/common/copy"
)

var itemCopyCanvasObjectPool = sync.Pool{
	New: func() interface{} { return &itemCopyCanvasObject{next: nil, v: nil} },
}

// In puts the given value at the tail of the queue.
func (q *CopyCanvasObjectQueue) In(v copy.CopyCanvasObject) {
	i := itemCopyCanvasObjectPool.Get().(*itemCopyCanvasObject)
	i.next = nil
	i.v = v

	var last, lastnext *itemCopyCanvasObject
	for {
		last = loadCopyCanvasObjectItem(&q.tail)
		lastnext = loadCopyCanvasObjectItem(&last.next)
		if loadCopyCanvasObjectItem(&q.tail) == last {
			if lastnext == nil {
				if casCopyCanvasObjectItem(&last.next, lastnext, i) {
					casCopyCanvasObjectItem(&q.tail, last, i)
					atomic.AddUint64(&q.len, 1)
					return
				}
			} else {
				casCopyCanvasObjectItem(&q.tail, last, lastnext)
			}
		}
	}
}

// Out removes and returns the value at the head of the queue.
// It returns nil if the queue is empty.
func (q *CopyCanvasObjectQueue) Out() copy.CopyCanvasObject {
	var first, last, firstnext *itemCopyCanvasObject
	for {
		first = loadCopyCanvasObjectItem(&q.head)
		last = loadCopyCanvasObjectItem(&q.tail)
		firstnext = loadCopyCanvasObjectItem(&first.next)
		if first == loadCopyCanvasObjectItem(&q.head) {
			if first == last {
				if firstnext == nil {
					return nil
				}
				casCopyCanvasObjectItem(&q.tail, last, firstnext)
			} else {
				v := firstnext.v
				if casCopyCanvasObjectItem(&q.head, first, firstnext) {
					atomic.AddUint64(&q.len, ^uint64(0))
					itemCopyCanvasObjectPool.Put(first)
					return v
				}
			}
		}
	}
}

// Len returns the length of the queue.
func (q *CopyCanvasObjectQueue) Len() uint64 {
	return atomic.LoadUint64(&q.len)
}
